<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEAR TOOTH COUNTER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            min-height: 100vh;
            font-weight: bold;
            text-transform: uppercase;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: #000;
            border: 4px solid #00ff00;
            padding: 30px;
            box-shadow: 8px 8px 0px #333;
        }

        .header h1 {
            font-size: 3.5em;
            color: #00ff00;
            text-shadow: 3px 3px 0px #333;
            letter-spacing: 4px;
            margin-bottom: 15px;
        }

        .header p {
            font-size: 1.2em;
            color: #ffffff;
            letter-spacing: 2px;
        }

        .teeth-display {
            background: #000;
            border: 6px solid #ff0000;
            padding: 40px;
            text-align: center;
            margin-bottom: 40px;
            box-shadow: 12px 12px 0px #333;
            position: relative;
        }

        .teeth-count {
            font-size: 8em;
            color: #ff0000;
            font-weight: 900;
            text-shadow: 5px 5px 0px #333;
            line-height: 1;
            margin-bottom: 20px;
        }

        .teeth-label {
            font-size: 2em;
            color: #ffffff;
            letter-spacing: 3px;
            text-shadow: 2px 2px 0px #333;
        }

        .status-bar {
            background: #333;
            border: 3px solid #ffffff;
            padding: 15px;
            margin-bottom: 30px;
            font-size: 1.1em;
            letter-spacing: 1px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 40px;
        }

        .section {
            background: #000;
            border: 4px solid #ffffff;
            padding: 30px;
            box-shadow: 8px 8px 0px #333;
        }

        .section-title {
            font-size: 1.8em;
            color: #ffffff;
            margin-bottom: 25px;
            text-shadow: 2px 2px 0px #333;
            letter-spacing: 2px;
        }

        #video {
            width: 100%;
            height: 300px;
            border: 3px solid #00ff00;
            background: #000;
            object-fit: cover;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 25px;
        }

        .btn {
            background: #333;
            border: 3px solid #ffffff;
            padding: 15px 25px;
            color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            box-shadow: 4px 4px 0px #666;
            transition: all 0.1s ease;
        }

        .btn:hover {
            background: #555;
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #666;
        }

        .btn:active {
            transform: translate(4px, 4px);
            box-shadow: none;
        }

        .btn:disabled {
            background: #1a1a1a;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: 4px 4px 0px #333;
        }

        .btn-primary {
            background: #ff0000;
            border-color: #ff0000;
            color: #ffffff;
        }

        .btn-primary:hover {
            background: #cc0000;
        }

        .btn-success {
            background: #00ff00;
            border-color: #00ff00;
            color: #000;
        }

        .btn-success:hover {
            background: #00cc00;
        }

        .upload-area {
            border: 4px dashed #ffffff;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 20px;
            background: #1a1a1a;
            transition: all 0.2s ease;
        }

        .upload-area:hover {
            background: #333;
            border-color: #00ff00;
        }

        .upload-area.dragover {
            background: #333;
            border-color: #ff0000;
        }

        .upload-text {
            font-size: 1.3em;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        #fileInput {
            display: none;
        }

        .preview-container {
            margin-bottom: 20px;
        }

        #imagePreview {
            max-width: 100%;
            max-height: 300px;
            border: 3px solid #00ff00;
            display: none;
        }

        .analysis-section {
            background: #000;
            border: 4px solid #ff0000;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 8px 8px 0px #333;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .detection-info {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            padding: 20px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .info-label {
            color: #ffffff;
        }

        .info-value {
            color: #00ff00;
            font-weight: bold;
        }

        .canvas-container {
            border: 3px solid #ffffff;
            background: #000;
        }

        #analysisCanvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .settings-panel {
            background: #1a1a1a;
            border: 3px solid #ffffff;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 6px 6px 0px #333;
        }

        .settings-title {
            font-size: 1.5em;
            color: #ffffff;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1em;
            color: #ffffff;
            letter-spacing: 1px;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            background: #333;
            border: 2px solid #00ff00;
            margin-bottom: 8px;
        }

        .setting-value {
            color: #ff0000;
            font-weight: bold;
            font-size: 1.2em;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            background: #000;
            border: 4px solid #ffff00;
            box-shadow: 8px 8px 0px #333;
        }

        .spinner {
            border: 6px solid #333;
            border-top: 6px solid #ffff00;
            border-radius: 0;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.5em;
            color: #ffff00;
            letter-spacing: 2px;
        }

        .error-message {
            background: #ff0000;
            color: #ffffff;
            padding: 20px;
            border: 3px solid #ffffff;
            margin: 20px 0;
            font-size: 1.2em;
            letter-spacing: 1px;
            box-shadow: 6px 6px 0px #333;
        }

        .success-message {
            background: #00ff00;
            color: #000;
            padding: 20px;
            border: 3px solid #000;
            margin: 20px 0;
            font-size: 1.2em;
            letter-spacing: 1px;
            box-shadow: 6px 6px 0px #333;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 30px;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2.5em;
            }
            
            .teeth-count {
                font-size: 5em;
            }
            
            .controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öôÔ∏è GEAR TOOTH COUNTER</h1>
            <p>INDUSTRIAL GRADE DETECTION SYSTEM</p>
        </div>

        <!-- PROMINENT TEETH COUNT DISPLAY -->
        <div class="teeth-display">
            <div class="teeth-count" id="mainTeethCount">--</div>
            <div class="teeth-label">DETECTED TEETH</div>
        </div>

        <!-- STATUS BAR -->
        <div class="status-bar" id="statusBar">
            STATUS: READY FOR ANALYSIS
        </div>

        <div class="main-grid">
            <!-- CAMERA SECTION -->
            <div class="section">
                <div class="section-title">üìπ LIVE CAMERA</div>
                <video id="video" autoplay muted playsinline></video>
                <div class="controls">
                    <button id="startCamera" class="btn btn-primary">START CAM</button>
                    <button id="capturePhoto" class="btn btn-success" disabled>CAPTURE</button>
                    <button id="stopCamera" class="btn" disabled>STOP CAM</button>
                </div>
            </div>

            <!-- UPLOAD SECTION -->
            <div class="section">
                <div class="section-title">üìÅ IMAGE UPLOAD</div>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-text">DROP GEAR IMAGE HERE</div>
                    <div style="font-size: 1em; opacity: 0.8;">OR CLICK TO BROWSE</div>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                <div class="preview-container">
                    <img id="imagePreview" alt="Preview">
                </div>
                <div class="controls">
                    <button id="analyzeImage" class="btn btn-success" disabled>ANALYZE</button>
                    <button id="clearImage" class="btn" disabled>CLEAR</button>
                </div>
            </div>
        </div>

        <!-- SETTINGS PANEL -->
        <div class="settings-panel">
            <div class="settings-title">‚öôÔ∏è DETECTION SETTINGS</div>
            <div class="setting-group">
                <label for="cannyThreshold1">EDGE SENSITIVITY: <span class="setting-value" id="cannyValue1">50</span></label>
                <input type="range" id="cannyThreshold1" min="10" max="150" value="50">
            </div>
            <div class="setting-group">
                <label for="cannyThreshold2">EDGE PRECISION: <span class="setting-value" id="cannyValue2">150</span></label>
                <input type="range" id="cannyThreshold2" min="50" max="300" value="150">
            </div>
            <div class="setting-group">
                <label for="minContourArea">MIN TOOTH SIZE: <span class="setting-value" id="minAreaValue">100</span></label>
                <input type="range" id="minContourArea" min="50" max="500" value="100">
            </div>
        </div>

        <!-- LOADING INDICATOR -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div class="loading-text">PROCESSING GEAR IMAGE...</div>
        </div>

        <!-- ANALYSIS RESULTS -->
        <div class="analysis-section" id="analysisSection" style="display: none;">
            <div class="section-title">üìä ANALYSIS RESULTS</div>
            <div class="analysis-grid">
                <div class="detection-info" id="detectionInfo">
                    <!-- Detection details will be populated here -->
                </div>
                <div class="canvas-container">
                    <canvas id="analysisCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BrutalistGearCounter {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('analysisCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.stream = null;
                this.currentImage = null;
                this.lastTeethCount = 0;
                
                this.initializeEventListeners();
                this.loadOpenCV();
                this.updateStatus('INITIALIZING OPENCV...');
            }

            initializeEventListeners() {
                // Camera controls
                document.getElementById('startCamera').addEventListener('click', () => this.startCamera());
                document.getElementById('stopCamera').addEventListener('click', () => this.stopCamera());
                document.getElementById('capturePhoto').addEventListener('click', () => this.captureAndAnalyze());

                // Upload controls
                document.getElementById('uploadArea').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                
                document.getElementById('uploadArea').addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('dragover');
                });
                
                document.getElementById('uploadArea').addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('dragover');
                });
                
                document.getElementById('uploadArea').addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFileUpload(files[0]);
                    }
                });

                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFileUpload(e.target.files[0]);
                    }
                });

                document.getElementById('analyzeImage').addEventListener('click', () => this.analyzeCurrentImage());
                document.getElementById('clearImage').addEventListener('click', () => this.clearImage());

                // Settings with real-time updates
                document.getElementById('cannyThreshold1').addEventListener('input', (e) => {
                    document.getElementById('cannyValue1').textContent = e.target.value;
                });
                
                document.getElementById('cannyThreshold2').addEventListener('input', (e) => {
                    document.getElementById('cannyValue2').textContent = e.target.value;
                });
                
                document.getElementById('minContourArea').addEventListener('input', (e) => {
                    document.getElementById('minAreaValue').textContent = e.target.value;
                });
            }

            async loadOpenCV() {
                return new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/opencv.js/4.8.0/opencv.js';
                    script.onload = () => {
                        cv.onRuntimeInitialized = () => {
                            console.log('OpenCV loaded successfully');
                            this.updateStatus('SYSTEM READY - SELECT IMAGE OR START CAMERA');
                            resolve();
                        };
                    };
                    script.onerror = () => {
                        this.showError('FAILED TO LOAD OPENCV - REFRESH PAGE');
                    };
                    document.head.appendChild(script);
                });
            }

            updateStatus(message) {
                document.getElementById('statusBar').textContent = `STATUS: ${message}`;
            }

            updateTeethCount(count, animated = true) {
                const display = document.getElementById('mainTeethCount');
                if (animated && count !== this.lastTeethCount) {
                    display.style.color = '#ffff00';
                    setTimeout(() => {
                        display.style.color = '#ff0000';
                    }, 500);
                }
                display.textContent = count.toString().padStart(2, '0');
                this.lastTeethCount = count;
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = `ERROR: ${message}`;
                document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.main-grid'));
                setTimeout(() => errorDiv.remove(), 5000);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success-message';
                successDiv.textContent = `SUCCESS: ${message}`;
                document.querySelector('.container').insertBefore(successDiv, document.querySelector('.main-grid'));
                setTimeout(() => successDiv.remove(), 3000);
            }

            async startCamera() {
                try {
                    this.updateStatus('ACCESSING CAMERA...');
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    
                    this.video.srcObject = this.stream;
                    
                    document.getElementById('startCamera').disabled = true;
                    document.getElementById('capturePhoto').disabled = false;
                    document.getElementById('stopCamera').disabled = false;
                    
                    this.updateStatus('CAMERA ACTIVE - READY TO CAPTURE');
                    
                } catch (error) {
                    console.error('Camera error:', error);
                    this.showError('CAMERA ACCESS DENIED');
                    this.updateStatus('CAMERA ACCESS FAILED');
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                    this.video.srcObject = null;
                }
                
                document.getElementById('startCamera').disabled = false;
                document.getElementById('capturePhoto').disabled = true;
                document.getElementById('stopCamera').disabled = true;
                
                this.updateStatus('CAMERA STOPPED');
            }

            captureAndAnalyze() {
                const canvas = document.createElement('canvas');
                canvas.width = this.video.videoWidth;
                canvas.height = this.video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(this.video, 0, 0);
                
                this.updateStatus('CAPTURING IMAGE...');
                
                canvas.toBlob((blob) => {
                    this.handleFileUpload(blob);
                    setTimeout(() => {
                        this.analyzeCurrentImage();
                        this.showSuccess('IMAGE CAPTURED AND ANALYZED');
                    }, 500);
                });
            }

            handleFileUpload(file) {
                this.updateStatus('LOADING IMAGE...');
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.currentImage = img;
                        const preview = document.getElementById('imagePreview');
                        preview.src = e.target.result;
                        preview.style.display = 'block';
                        
                        document.getElementById('analyzeImage').disabled = false;
                        document.getElementById('clearImage').disabled = false;
                        
                        this.updateStatus('IMAGE LOADED - READY FOR ANALYSIS');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            clearImage() {
                this.currentImage = null;
                document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('analyzeImage').disabled = true;
                document.getElementById('clearImage').disabled = true;
                document.getElementById('analysisSection').style.display = 'none';
                document.getElementById('fileInput').value = '';
                this.updateTeethCount(0, false);
                document.getElementById('mainTeethCount').textContent = '--';
                this.updateStatus('IMAGE CLEARED');
            }

            analyzeCurrentImage() {
                if (!this.currentImage || typeof cv === 'undefined') {
                    this.showError('OPENCV NOT READY OR NO IMAGE SELECTED');
                    return;
                }

                this.updateStatus('ANALYZING GEAR TEETH...');
                document.getElementById('loading').style.display = 'block';
                document.getElementById('analysisSection').style.display = 'none';

                setTimeout(() => {
                    try {
                        const result = this.processGearImage(this.currentImage);
                        this.displayResults(result);
                        this.updateTeethCount(result.teethCount, true);
                        this.updateStatus(`ANALYSIS COMPLETE - ${result.teethCount} TEETH DETECTED`);
                        this.showSuccess(`DETECTED ${result.teethCount} GEAR TEETH`);
                    } catch (error) {
                        console.error('Analysis error:', error);
                        this.showError('ANALYSIS FAILED - TRY DIFFERENT SETTINGS');
                        this.updateStatus('ANALYSIS ERROR');
                    } finally {
                        document.getElementById('loading').style.display = 'none';
                    }
                }, 200);
            }

            processGearImage(image) {
                // Setup canvas with proper sizing
                const maxWidth = 800;
                const maxHeight = 600;
                const scale = Math.min(maxWidth / image.width, maxHeight / image.height, 1);
                
                this.canvas.width = image.width * scale;
                this.canvas.height = image.height * scale;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                
                // Convert to OpenCV format
                const src = cv.imread(this.canvas);
                const gray = new cv.Mat();
                const blurred = new cv.Mat();
                const edges = new cv.Mat();
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                
                try {
                    // Enhanced preprocessing
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    
                    // Apply multiple blur techniques for better edge detection
                    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                    
                    // Adaptive histogram equalization for better contrast
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    const enhanced = new cv.Mat();
                    clahe.apply(blurred, enhanced);
                    
                    // Edge detection with user settings
                    const threshold1 = parseInt(document.getElementById('cannyThreshold1').value);
                    const threshold2 = parseInt(document.getElementById('cannyThreshold2').value);
                    cv.Canny(enhanced, edges, threshold1, threshold2);
                    
                    // Morphological operations to clean up edges
                    const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                    const morphed = new cv.Mat();
                    cv.morphologyEx(edges, morphed, cv.MORPH_CLOSE, kernel);
                    
                    // Find contours
                    cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    
                    // Advanced gear tooth detection
                    const minArea = parseInt(document.getElementById('minContourArea').value);
                    const detectedTeeth = [];
                    let teethCount = 0;
                    
                    // Find the largest contour (likely the gear outline)
                    let maxArea = 0;
                    let gearContour = null;
                    
                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour);
                        if (area > maxArea) {
                            maxArea = area;
                            if (gearContour) gearContour.delete();
                            gearContour = contour.clone();
                        }
                    }
                    
                    // Analyze each contour for gear teeth characteristics
                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour);
                        
                        if (area > minArea && area < maxArea * 0.1) {
                            // Calculate contour properties
                            const hull = new cv.Mat();
                            cv.convexHull(contour, hull);
                            const hullArea = cv.contourArea(hull);
                            const solidity = area / hullArea;
                            
                            // Calculate aspect ratio
                            const rect = cv.boundingRect(contour);
                            const aspectRatio = rect.width / rect.height;
                            
                            // Calculate extent (contour area / bounding rect area)
                            const extent = area / (rect.width * rect.height);
                            
                            // Enhanced tooth detection criteria
                            const isValidTooth = (
                                solidity > 0.4 && solidity < 0.95 &&
                                aspectRatio > 0.3 && aspectRatio < 3.0 &&
                                extent > 0.3 && extent < 0.9 &&
                                area > minArea && area < maxArea * 0.05
                            );
                            
                            if (isValidTooth) {
                                const moments = cv.moments(contour);
                                const centroid = {
                                    x: moments.m10 / moments.m00,
                                    y: moments.m01 / moments.m00
                                };
                                
                                detectedTeeth.push({
                                    contour: contour.clone(),
                                    area: area,
                                    solidity: solidity,
                                    aspectRatio: aspectRatio,
                                    extent: extent,
                                    centroid: centroid
                                });
                                teethCount++;
                            }
                            
                            hull.delete();
                        }
                    }
                    
                    // Draw results on canvas
                    this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw gear outline if found
                    if (gearContour) {
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        for (let j = 0; j < gearContour.rows; j++) {
                            const point = gearContour.data32S.slice(j * 2, j * 2 + 2);
                            const x = point[0];
                            const y = point[1];
                            if (j === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                    
                    // Draw detected teeth with numbers
                    detectedTeeth.forEach((tooth, index) => {
                        // Draw tooth contour
                        this.ctx.strokeStyle = '#ff0000';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        for (let j = 0; j < tooth.contour.rows; j++) {
                            const point = tooth.contour.data32S.slice(j * 2, j * 2 + 2);
                            const x = point[0];
                            const y = point[1];
                            if (j === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                        
                        // Draw tooth number
                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.font = 'bold 16px Courier New';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText((index + 1).toString(), tooth.centroid.x, tooth.centroid.y);
                        
                        // Draw center point
                        this.ctx.fillStyle = '#ff0000';
                        this.ctx.beginPath();
                        this.ctx.arc(tooth.centroid.x, tooth.centroid.y, 3, 0, 2 * Math.PI);
                        this.ctx.fill();
                    });
                    
                    // Cleanup OpenCV matrices
                    const matrices = [src, gray, blurred, edges, contours, hierarchy, enhanced, clahe, morphed, kernel];
                    matrices.forEach(mat => {
                        if (mat && mat.delete) mat.delete();
